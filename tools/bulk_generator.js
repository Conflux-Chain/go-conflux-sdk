const fs = require("fs")

const initResultMapping = {
    "*types.Hash": "var hash types.Hash\n\tresult := &hash",
    "*string": "var str string\n\tresult := &str",
}

function genBulkFile(filePath, clientName, missingFuncs) {

    // console.log("filepath", filePath, "client", clientName)

    let content = fs.readFileSync(filePath).toString()
    let bulkStrctName = clientName.replace(/Rpc(.*)Client/, "Bulk$1Caller")

    const funcs = content.split("func ").map(v => "func " + v)
    const newFuncs = funcs.map(item => genBulkFuncs(item))
    newFuncs.concat(missingFuncs)

    const head = `
        // This file is auto-generated by bulk_generator, please don't edit
        package bulk

        import (
            "fmt"
        
            "github.com/Conflux-Chain/go-conflux-sdk/interfaces"
            "github.com/Conflux-Chain/go-conflux-sdk/rpc"
            "github.com/Conflux-Chain/go-conflux-sdk/types"
            "github.com/ethereum/go-ethereum/common/hexutil"
        )
        
        type ${bulkStrctName} struct {
            caller     interfaces.RpcCallerCore
            batchElems *[]rpc.BatchElem
        }
        
        func New${bulkStrctName}(caller interfaces.RpcCallerCore, batchElems *[]rpc.BatchElem) *${bulkStrctName} {
            return &BulkCfxCaller{caller, batchElems}
        }
        
        func (b *${bulkStrctName}) Call() ([]error, error) {
            return batchCall(b.caller, b.batchElems)
        }\n\n`


    return head.replace("\t", "") + newFuncs.join("")
}

/**
 * @param  {String} file
 * @param  {Array} missingFuns
 */
function genBulkFuncs(func) {
    let any = "[\\s\\S]"
    let reg = new RegExp(`func \\(client \\*(RpcCfxClient)\\)` +    // func (client *RpcCfxClient) <<<>>> 分组1---结构名称 RpcCfxClient
        `(${any}*\\)).* ` +                                          // 分组2---方法签名 GetNextNonce(address types.Address, epoch ...*types.Epoch) 
        `\\(.*? (.*?),.*?\\)` + `.*?\\{` +                            // (nonce *hexutil.Big, err error) {  <<<<>>>  分组3---返回值类型 *hexutil.Big
        `(${any}*?)err` +                                           // realEpoch := get1stEpochIfy(epoch)\nerr <<<<>>> 分组4---call前操作 realEpoch := get1stEpochIfy(epoch) 
        `.*?wrappedCallRPC\\(${any}*?,` +                                //  = client.core.wrappedCallRPC(&nonce, 
        `(${any}*?)\\)` +                                                //  "cfx_getNextNonce", address, realEpoch) <<<<>>> 分组5---rpc元素 "cfx_getNextNonce", address, realEpoch
        `(${any}*?)` +                                              // 分组6---call后操作
        `return${any}*?` +                                          // result
        `\\}(${any}*)`                                              // }\n//comments <<<>>> 分组7---下一个function的comments
        , "ig")                                                //}


    //     func = `func (client *RpcCfxClient) CheckBalanceAgainstTransaction(accountAddress types.Address,
    //         contractAddress types.Address,
    //         gasLimit *hexutil.Big,
    //         gasPrice *hexutil.Big,
    //         storageLimit *hexutil.Big,
    //         epoch ...*types.Epoch) (response types.CheckBalanceAgainstTransactionResponse, err error) {
    //         realEpoch := get1stEpochIfy(epoch)
    //         err = client.core.wrappedCallRPC(&response,
    //                 "cfx_checkBalanceAgainstTransaction", accountAddress, contractAddress,
    //                 gasLimit, gasPrice, storageLimit, realEpoch)
    //         return
    // }`

    let matchRes = reg.exec(func)
    console.log(reg)
    // console.log(matchRes)

    if (matchRes == null) {
        console.log("not matched:", func)
        return "//ignore\n\n\n"
    }

    let [, clientName, funcSign, returnType, preCall, rpcBody, postCall, comments] = matchRes

    console.log(funcSign)
    // if (funcSign.trim().startsWith("Call("))
    //     return "//ignore\n\n\n"

    clientName = clientName.replace(/Rpc(.*)Client/, "Bulk$1Caller")
    returnType = (returnType[0] == "*" || returnType[0] == "[") ? returnType : "*" + returnType

    let initResult = genInitResult(returnType)
    let newOne = `func(client *${clientName}) ${funcSign} ${returnType} {\n\t${initResult}${preCall}` +
        `*client.batchElems = append(*client.batchElems, newBatchElem(result, ` + `${rpcBody}))${postCall}` +
        `return result\n` +
        `}\n${comments}`

    newOne = newOne.replace(/if err != nil {.*?}/gs, "")

    return newOne
}

(function () {
    const missingFuncs = [`// GetStatus returns status of connecting conflux node
    func (client *BulkCfxCaller) GetStatus() *hexutil.Big {
        result := &hexutil.Big{}
        *client.batchElems = append(*client.batchElems, newBatchElem(result, "cfx_getStatus"))
        return result
    }`]
    const BulkCfxCaller = genBulkFile("/Users/wangdayong/myspace/mywork/go-conflux-sdk/cfxclient/rpc_cfx.go", "RpcCfxClient", missingFuncs)
    fs.writeFileSync("./bulk_caller_cfx.go", BulkCfxCaller)
})()


function genInitResult(returnType) {
    if (initResultMapping[returnType])
        return initResultMapping[returnType]

    let initResult
    switch (returnType[0]) {
        case "*":
            initResult = `result := &${returnType.substr(1)}{}`
            break
        case "[":
            initResult = `result:= make(${returnType}, 0)`
            break
        default:
            break
    }

    return initResult
}

